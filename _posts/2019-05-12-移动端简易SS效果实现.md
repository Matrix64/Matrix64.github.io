---
layout: post
title: "移动端廉价Subsurface Scattering效果实现"
description: "本篇记录了廉价Subsurface Scattering效果实现"
modified: 2019-05-12
tags: [Unity, Shader]
image:
  feature: /CheapSS/title.jpg
---

# 哈哈,好久不见XD

最近加入了一个新游戏开发团队,在调整好新的作息时间后终于有空能整理一下前一段时间作的东西了.

这是一个手游项目里预定会出场的蘑菇敌人,这里的目标是在移动平台上实现蘑菇头顶矿石的通透感与质感,因为项目本身还在dev阶段,请允许我给蘑菇兄做一些马赛克处理(￣^￣)ゞ

<figure class="large">
    <div class="myvideo">
       <video  style="display:block; width:100%; height:auto;" autoplay controls loop="loop">
           <source src="/images/CheapSS/output.mp4" type="video/mp4" />
       </video>
    </div>
<figcaption>与其说是矿石,我觉得更接近玉石</figcaption>
</figure>

拿到这个需求的时候,我第一反应其实是通过折射计算来实现通透感,不过很快这个想法就被否了,因为手机端不像是我以前一直开发的PC端那么自由,想要做折射就免不了计算GrabPass,然而这个操作在移动设备上确实代价太高,或者说在手机端的性价比不高.

于是第二个想到的就是简易SS的实现,因为早些时间刚好看到过相关的**文章**<sup>[1]</sup>,不v过这篇文章也是基于更早的一篇**GDC文章**<sup>[2]</sup>而来,本篇也是基于这个理论进行的实践.

[1][Fast Subsurface Scattering in Unity by 
Alan Zucconi](https://www.alanzucconi.com/2017/08/30/fast-subsurface-scattering-1/)

[2][GDC 2011 – Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look](https://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/)

## 实时计算下的半透明效果

**3DCG追求的不是真,而是看起来真**

其实Alan解释的很清楚,真正的SS效果是基于光线在照射到实体或者半透明物体时,一部分光线就会进入物体内部,经过一定次数的反弹,然后再次从物体表面射出.在光线反弹的过程中,物体内部就被照亮了.有这种特性的物质比如说皮肤,玉石还有牛奶等等.

<figure>
 <img src="/images/CheapSS/previewSS.jpg" alt="">
</figure>

然而问题也在这里,一束光线在物体内部反弹的次数就可能有成百上千次,而物体表面的一个点也可能同时接收到多个光源发射来的光线.这就意味着想要得到理论上完美的SS效果得进行庞大的光线计算,这显然在移动平台上是不现实的.

在GDC2011上,Colin Barré-Brisebois和Marc Bouchard就发表了一篇技术演讲,介绍了一种并非物理精确,但确实有效的廉价SS实现方案,这个方案日后也成为了寒霜2引擎的一部分,并用于制作男友3(BF3).

对于一个不透明物体来说,主光源能照亮的部分就是光线 *L* 与顶点法线 *N* 夹角90°以内的范围,超过90°的将不受光(下图左),而技术演讲中提到的半透明材质,使用假想的光线 *-L* 来照亮,这就好像真的有这些光线穿过了物体一样(下图右).

<figure>
 <img src="/images/CheapSS/translucent_FakeLight.jpg" alt="">
</figure>

对于正面受光的部分,就和正常处理光照的逻辑一样.需要设计的是背面假想光源*-L*的计算方式.

### 如何计算假想光源

顺着之前的思路,现在要渲染模型背光部位的像素(如下图红点处),因为处在常规渲染的阴影部位,需要由*-L*来进行照亮,现在可以分析一下观察角度的两个极端情况,一种发生在视角方向V<sub>A</sub>与*-L*垂直的时候,这时候刚好可以从侧面看到被观察点;另一种发生在视角方向V<sub>A</sub>与*-L*平行的时候,这时候就是从完全背光的位置进行观察.

<figure>
 <img src="/images/CheapSS/translucent_drawPoint.jpg" alt="">
</figure>

这时候,红点的背光亮度*I<sub>back</sub>*等于*V* · *-L* , 在原本的diffuse计算过程中, diffuse计算则是*N* · *L*.这里在计算光照的时候没有包括**表面法线**.

### 次表面扭曲

不过表面法线是需要包括在计算内的,就算影响的结果很少,也会在光线射出物体表面的时候产生变化.这里就引入一个新的参数**次表面扭曲值**, 这个值控制了*-L*的方向转向*N*的强度.由此,新的计算公式变成了:

*I<sub>back</sub>* = V · —〈L + *N*δ〉

当δ=0时,函数返回V · —L,这和之前计算的一样.当δ=1时,函数返回V · −〈L + *N*〉.这种计算方式和Blinn-Phong模型中计算Half Direction的过程很像.

pic

上图解释了这个计算的过程,紫色的向量*H*夹在*L*与*N*之间,δ值在0~1之间变化对受光区域的影响发生在紫色扇形范围内.如下图所示,δ的变化可以模拟光源在橙色与紫色之间变化的过程.

pic

